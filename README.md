# Universal Symbolic Core (USC) ðŸ”¬âš¡

[![License: Apache 2.0](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
[![GitHub repo size](https://img.shields.io/github/repo-size/michaelgermini/Universal-Symbolic-Core-USC)](https://github.com/michaelgermini/Universal-Symbolic-Core-USC)
[![GitHub last commit](https://img.shields.io/github/last-commit/michaelgermini/Universal-Symbolic-Core-USC)](https://github.com/michaelgermini/Universal-Symbolic-Core-USC)

## ðŸŒŸ Vue d'Ensemble

**USC (Universal Symbolic Core)** est un systÃ¨me symbolique universel conÃ§u pour la communication inter-IA, les environnements contraints et l'archivage galactique. Il transcende les limitations des alphabets humains (Unicode) en dÃ©finissant un **alphabet conceptuel atomique** avec une sÃ©mantique parfaitement neutre.

### ðŸ—ï¸ Architecture HiÃ©rarchique

```
USC-256 (Corps Universel Ã‰tendu)
â”œâ”€â”€ USC-128 (Core RecommandÃ©)          # IA scientifiques, calcul distribuÃ©
â”‚   â””â”€â”€ USC-96 (Noyau Ultra-Compact)   # Survivance, IoT, HF/LoRa
```

**CaractÃ©ristiques Techniques :**
- **Compression sÃ©mantique** : Ratio 10:1 vs langage naturel
- **Encodage binaire** : 7 bits/symbole (USC-96/128), 8 bits/symbole (USC-256)
- **Entropie conceptuelle** : RÃ©duction de la polysÃ©mie par canonisation
- **CompatibilitÃ©** : De l'IoT aux supercalculateurs

### ðŸŽ¯ Cas d'Usage Principaux

| Domaine | Variante RecommandÃ©e | Avantages USC |
|---------|---------------------|---------------|
| **RÃ©seaux Contrainte** (HF, LoRa, Sigfox) | USC-96 | Overhead minimal, robustesse |
| **IA Locale/Sci** | USC-128 | ExpressivitÃ© Ã©quilibrÃ©e |
| **SystÃ¨mes Complexes** | USC-256 | Couverture multi-disciplinaire |
| **Archivage Long Terme** | USC-96 | StabilitÃ© temporelle |

---

## ðŸ“š Table des MatiÃ¨res

### ðŸ“– Livre Principal (`book/`)
1. **[PrÃ©face](book/00_Preface.md)** - Motivation et vision long terme
2. **Partie I** - Principes Fondamentaux
   - [Chapitre 1](book/PartI_Chapter01_Definition.md) - DÃ©finition et portÃ©e
   - [Chapitre 2](book/PartI_Chapter02_TheorieSymboles.md) - ThÃ©orie des symboles
   - [Chapitre 3](book/PartI_Chapter03_Objectifs.md) - Objectifs du systÃ¨me
3. **Partie II** - Architecture USC
   - [Chapitre 4](book/PartII_Chapter04_USC96_full.md) - USC-96 (Core Ultra-Compact)
   - [Chapitre 5](book/PartII_Chapter05_USC128_full.md) - USC-128 (Core RecommandÃ©)
   - [Chapitre 6](book/PartII_Chapter06_USC256_full.md) - USC-256 (Corps Universel)
4. **Partie III** - Structures Internes
   - [Chapitre 7](book/PartIII_Chapter07_ClassesSymboliques.md) - Classes symboliques
   - [Chapitre 8](book/PartIII_Chapter08_BigrammesTrigrammes.md) - Bi/Tri-grammes
   - [Chapitre 9](book/PartIII_Chapter09_GrammaireInterne.md) - Grammaire EBNF
5. **Partie IV** - CompatibilitÃ© & IntÃ©gration
   - [Chapitre 10](book/PartIV_Chapter10_CompatReseauxContraints.md) - RÃ©seaux contraints
   - [Chapitre 11](book/PartIV_Chapter11_CompatDataInternet.md) - Data & Internet
   - [Chapitre 12](book/PartIV_Chapter12_CompatIA.md) - Intelligence Artificielle
   - [Chapitre 13](book/PartIV_Chapter13_CompatOffline.md) - SystÃ¨mes offline
   - [Chapitre 14](book/PartIV_Chapter14_CompatMaterielle.md) - CompatibilitÃ© matÃ©rielle
6. **Partie V** - SÃ©curitÃ© & SouverainetÃ©
   - [Chapitre 15](book/PartV_Chapter15_CryptoUSC.md) - Cryptographie USC-native
   - [Chapitre 16](book/PartV_Chapter16_Antilogs.md) - Anti-logs et souverainetÃ©
7. **Partie VI** - Annexes Techniques
   - [Annexe A](book/PartVI_AnnexeA_Tables.md) - Tables canoniques
   - [Annexe B](book/PartVI_AnnexeB_EBNF.md) - Grammaire formelle EBNF
   - [Annexe C](book/PartVI_AnnexeC_DiagrammesCompat.md) - Diagrammes de compatibilitÃ©
   - [Annexe D](book/PartVI_AnnexeD_ExemplesEncodage.md) - Exemples d'encodage
   - [Annexe E](book/PartVI_AnnexeE_ComparatifEncodages.md) - Comparatif encodings
- [Annexe F](book/PartVI_AnnexeF_TransmissionInterstellaire.md) - Transmission interstellaire
- [Annexe G](book/PartVI_AnnexeG_ImplRef.md) - ImplÃ©mentation de rÃ©fÃ©rence
- [Annexe H](book/PartVI_AnnexeH_ComparatifSystemes.md) - Comparatif systÃ¨mes existants

### ðŸ“‹ Documents de RÃ©fÃ©rence
- **[Index ThÃ©matique](book/Index_thematique.md)** - Navigation par concepts
- **[Conclusion & Roadmap](book/Conclusion_Roadmap.md)** - Vision USC-512
- **[Rapport d'Analyse](RAPPORT_PROJET_USC.md)** - Ã‰tat du projet

### ðŸ“Š Tables Symboliques Canoniques
- **[USC-96](usc_96_table.md)** - 96 symboles (noyau ultra-compact)
- **[USC-128](usc_128_table.md)** - 128 symboles (core recommandÃ©)
- **[USC-256](usc_256_table.md)** - 256 symboles (corps universel)

---

## ðŸš€ Quick Start pour DÃ©veloppeurs

### ðŸ“¦ Installation & Setup

```bash
# Cloner le dÃ©pÃ´t
git clone https://github.com/michaelgermini/Universal-Symbolic-Core-USC.git
cd Universal-Symbolic-Core-USC

# Charger les tables de symboles (Python exemple)
import json

# Charger USC-96
with open('usc_96_table.md', 'r', encoding='utf-8') as f:
    # Parser le format Markdown pour extraire les symboles
    symbols_96 = parse_usc_table(f.read())

# Structure typique d'un symbole
symbol = {
    'id': 42,
    'symbol': 'REL-CAUSE',
    'class': 'REL-*',
    'gloss': 'Relation de causalitÃ©',
    'binary': '0x2A'  # 42 en hex
}
```

### ðŸ”§ ImplÃ©mentation Basique (Python)

```python
class USC96Encoder:
    def __init__(self):
        self.magic = b'\x55\x43'  # "UC" pour Universal Core

    def encode(self, symbol_ids: list[int]) -> bytes:
        """Encode une liste d'IDs USC-96 en octets"""
        if not all(0 <= id <= 95 for id in symbol_ids):
            raise ValueError("IDs must be in range 0-95 for USC-96")

        # Format de trame: MAGIC(2) + VERSION(1) + LENGTH(2) + PAYLOAD + CRC(2)
        version = 0x01
        length = len(symbol_ids)
        payload = bytes(symbol_ids)  # 1 octet par symbole

        frame = self.magic + bytes([version]) + length.to_bytes(2, 'big') + payload
        crc = self.crc16(frame)
        return frame + crc.to_bytes(2, 'big')

    def decode(self, frame: bytes) -> list[int]:
        """DÃ©code une trame USC-96"""
        if len(frame) < 7 or frame[:2] != self.magic:
            raise ValueError("Invalid USC frame")

        version = frame[2]
        length = int.from_bytes(frame[3:5], 'big')
        payload = frame[5:-2]
        crc_received = int.from_bytes(frame[-2:], 'big')

        # VÃ©rifier CRC
        crc_calculated = self.crc16(frame[:-2])
        if crc_received != crc_calculated:
            raise ValueError("CRC mismatch")

        return list(payload)

    @staticmethod
    def crc16(data: bytes) -> int:
        """CRC-16-CCITT"""
        crc = 0xFFFF
        for byte in data:
            crc ^= byte << 8
            for _ in range(8):
                if crc & 0x8000:
                    crc = (crc << 1) ^ 0x1021
                else:
                    crc <<= 1
                crc &= 0xFFFF
        return crc

# Exemple d'usage
encoder = USC96Encoder()

# Encoder une sÃ©quence conceptuelle simple
# IDs: EXIST(0), CAUSE(42), EVENT(15)
message = encoder.encode([0, 42, 15])
print(f"Trame encodÃ©e: {message.hex()}")

# DÃ©coder
decoded = encoder.decode(message)
print(f"IDs dÃ©codÃ©s: {decoded}")
```

### ðŸŽ¯ Exemple d'Encodage Conceptuel

**Concept :** "La tempÃ©rature cause l'Ã©vaporation"
**Traduction USC-96 :**
- TEMP(85) + CAUSE(42) + EVAPOR(87)

```python
# Encodage binaire
concept_ids = [85, 42, 87]  # TEMP, CAUSE, EVAPOR
frame = encoder.encode(concept_ids)

# RÃ©sultat: MAGIC(5543) + VERSION(01) + LENGTH(0003) + PAYLOAD(55 2A 57) + CRC(XXXX)
# Transmission: 7 octets pour exprimer un concept complexe
```

---

## ðŸ›ï¸ Standards & SpÃ©cifications

### ðŸ“‹ ConformitÃ© Technique
- **Style rÃ©dactionnel** : RFC/IETF (normatif, technique)
- **Langue** : FranÃ§ais (pour prÃ©cision conceptuelle)
- **Encodage** : UTF-8 pour tous les fichiers
- **Format de tables** : Markdown structurÃ© avec mÃ©tadonnÃ©es

### ðŸ”— CompatibilitÃ© Existante
- **Unicode** : Mappings partiels (Annexe A)
- **RDF/OWL** : Ponts sÃ©mantiques possibles
- **JSON** : Format de transport `application/usc+json`
- **Protobuf** : Alternative binaire pour gros volumes

### ðŸ“Š MÃ©triques de Performance

| MÃ©trique | USC-96 | USC-128 | USC-256 |
|----------|--------|---------|---------|
| **Symboles** | 96 | 128 | 256 |
| **Bits/symbole** | 7 | 7 | 8 |
| **Overhead min** | 1 octet | 1 octet | 1 octet |
| **Ratio compression** | 10:1 | 12:1 | 15:1 |
| **Latence typique** | <1ms | <1ms | <2ms |

---

## ðŸ› ï¸ Outils & Ressources

### ðŸ”§ Outils de DÃ©veloppement
- **Tables canoniques** : DÃ©finition normative des symboles
- **Grammaire EBNF** : Parsing formel des expressions
- **Pseudo-code** : ImplÃ©mentations de rÃ©fÃ©rence
- **Exemples** : Cas d'usage concrets

### ðŸ“š Ressources SupplÃ©mentaires
- **[Rapport d'Analyse](RAPPORT_PROJET_USC.md)** - Ã‰tat dÃ©taillÃ© du projet
- **[Index ThÃ©matique](book/Index_thematique.md)** - Navigation par concepts
- **[Diagrammes](book/PartVI_AnnexeC_DiagrammesCompat.md)** - Visualisations ASCII
- **[Exemples](book/PartVI_AnnexeD_ExemplesEncodage.md)** - Cas pratiques

### ðŸŒ Ã‰cosystÃ¨me
- **GitHub** : [michaelgermini/Universal-Symbolic-Core-USC](https://github.com/michaelgermini/Universal-Symbolic-Core-USC)
- **Licence** : Apache 2.0 (permissive, commerciale OK)
- **Contributions** : Bienvenues (voir section ci-dessous)

---

## ðŸ¤ Contributions & Gouvernance

### ðŸ“ Comment Contribuer

Nous encourageons les contributions dans ces domaines :

#### ðŸ”¬ **Nouveaux Symboles (USC-512)**
```markdown
Proposition de symbole :
- ID: [proposÃ©]
- Classe: [AX-*/REL-*/OP-*/etc.]
- Gloss: [dÃ©finition prÃ©cise]
- Justification: [cas d'usage, domaine]
- CompatibilitÃ©: [impact sur versions existantes]
```

#### ðŸ› **Corrections & AmÃ©liorations**
- Corrections de dÃ©finitions symboliques
- AmÃ©liorations de la grammaire EBNF
- Optimisations des algorithmes d'encodage
- Nouveaux exemples d'usage

#### ðŸ’» **ImplÃ©mentations**
- BibliothÃ¨ques de rÃ©fÃ©rence (Python, Rust, C++)
- Outils de validation
- Benchmarks de performance
- IntÃ©grations frameworks

### ðŸ“‹ Processus de Contribution
1. **Fork** le dÃ©pÃ´t
2. **CrÃ©er** une branche `feature/nom-fonctionnalite`
3. **Commiter** avec messages descriptifs
4. **Push** et crÃ©er une **Pull Request**
5. **Discussion** communautaire et validation

### ðŸŽ¯ Roadmap Communautaire
- **v0.2** : ImplÃ©mentation Python de rÃ©fÃ©rence
- **v0.3** : Benchmarks vs JSON/Protobuf
- **v0.4** : SpÃ©cification USC-512 (premiers symboles)
- **v1.0** : Standardisation IETF (horizon 2026)

---

## ðŸ“„ Licence

**Apache License 2.0**
- Usage commercial autorisÃ©
- Distribution libre
- Modification et redistribution permises
- Attribution requise

Voir [`LICENSE`](LICENSE) pour les termes complets.

---

## ðŸ™ Remerciements

- **Auteur** : Michael Germini
- **MÃ©thodologie** : Approche RFC/IETF pour spÃ©cifications techniques
- **Inspiration** : Recherche en IA, systÃ¨mes embarquÃ©s, archivage long terme
- **CommunautÃ©** : Ouvert aux contributions et retours

---

## ðŸ”— Liens Utiles

- ðŸ“Š **[Rapport Complet](RAPPORT_PROJET_USC.md)** - Analyse dÃ©taillÃ©e du projet
- ðŸ“– **[Index ThÃ©matique](book/Index_thematique.md)** - Navigation conceptuelle
- ðŸ› ï¸ **[ImplÃ©mentation](book/PartVI_AnnexeG_ImplRef.md)** - Guide dÃ©veloppeur
- ðŸŒŒ **[Transmission Interstellaire](book/PartVI_AnnexeF_TransmissionInterstellaire.md)** - Vision galactique

---

*â€œL'USC : quand l'IA parle enfin le mÃªme langage que l'universâ€* âœ¨

Structure du dÃ©pÃ´t
------------------

- `book/`
  - `00_Preface.md` : prÃ©face, motivation, vision long terme.
  - `PartI_*.md` : principes fondamentaux (dÃ©finition, thÃ©orie des symboles, objectifs).
  - `PartII_*.md` : architecture USCâ€‘96 / USCâ€‘128 / USCâ€‘256 (chapitres + versions _full_ dÃ©taillÃ©es).
  - `PartIII_*.md` : structures internes (classes symboliques, biâ€‘/triâ€‘grammes, grammaire).
  - `PartIV_*.md` : compatibilitÃ© & intÃ©gration (rÃ©seaux contraints, Data/Internet, IA, offline, matÃ©riel).
  - `PartV_*.md` : sÃ©curitÃ© & souverainetÃ© (cryptographie USCâ€‘native, antiâ€‘logs).
  - `PartVI_*.md` : annexes techniques (tables, EBNF, diagrammes, exemples dâ€™encodage, comparatif, transmission interstellaire, implÃ©mentation de rÃ©fÃ©rence).
  - `Index_thematique.md` : index thÃ©matique des notions importantes.
  - `Conclusion_Roadmap.md` : conclusion et feuille de route (USCâ€‘512, outils, gouvernance).
- `usc_96_table.md` : table canonique USCâ€‘96 (IDs, classes, dÃ©finitions, exemple dâ€™encodage).
- `usc_128_table.md` : table Ã©tendue USCâ€‘128.
- `usc_256_table.md` : table universelle Ã©tendue USCâ€‘256.
- `content.ini` : version longue / historique du contenu (source initiale).
- `livre chapitre.mak` : plan dÃ©taillÃ© du livre (table des matiÃ¨res structurÃ©e).

Licence
-------

- Ce projet est distribuÃ© sous la **licence Apache 2.0**.  
- Voir le fichier `LICENSE` Ã  la racine du dÃ©pÃ´t pour les termes complets.

Comment lire le livre
---------------------

Ordre recommandÃ© :

1. `book/00_Preface.md`  
2. `book/PartI_Chapter01_Definition.md` â†’ `PartI_Chapter02_TheorieSymboles.md` â†’ `PartI_Chapter03_Objectifs.md`  
3. `book/PartII_Chapter04_USC96_full.md`, puis `PartII_Chapter05_USC128_full.md`, `PartII_Chapter06_USC256_full.md`  
4. Structures internes : `PartIII_Chapter07_ClassesSymboliques.md`, `PartIII_Chapter08_BigrammesTrigrammes.md`, `PartIII_Chapter09_GrammaireInterne.md`  
5. CompatibilitÃ© & sÃ©curitÃ© : Parties IV et V  
6. Annexes techniques : `PartVI_AnnexeA` â†’ `PartVI_AnnexeB` â†’ `PartVI_AnnexeD` â†’ `PartVI_AnnexeG`  
7. `Index_thematique.md` et `Conclusion_Roadmap.md` pour naviguer et voir la vision globale.

Comment implÃ©menter USC en pratique
-----------------------------------

### 1. Choisir la variante et le profil

- **USCâ€‘96** :
  - pour rÃ©seaux trÃ¨s contraints (HF, LoRa, Sigfox, IoT basique),
  - pour microcontrÃ´leurs ou FPGA simples.
- **USCâ€‘128** :
  - pour IA gÃ©nÃ©rales / scientifiques, services backend, modÃ©lisation.
- **USCâ€‘256** :
  - pour plateformes multiâ€‘domaines (physique, chimie, bio/med, espace, info/calcul).

Ensuite, dÃ©finir un **profil** :

- sousâ€‘ensemble de symboles rÃ©ellement utilisÃ©s ;
- contraintes spÃ©cifiques (ex. â€œprofil LoRaâ€‘96â€, â€œprofil IAâ€‘Sciâ€‘128â€, etc.).

RÃ©fÃ©rence :  
â†’ `book/PartII_Chapter04_USC96_full.md` / `05_USC128_full.md` / `06_USC256_full.md`  
â†’ `book/PartIV_Chapter10_CompatReseauxContraints.md` et suivants.

### 2. Charger les tables de symboles

- Parser les fichiers :
  - `usc_96_table.md`,
  - `usc_128_table.md`,
  - `usc_256_table.md`.
- Construire en mÃ©moire :
  - une table indexÃ©e par ID (0..N) pour un accÃ¨s rapide,
  - et/ou un dictionnaire `SYMBOL â†’ ID` pour les outils de debug.

RÃ©fÃ©rence :  
â†’ `book/PartVI_AnnexeA_Tables.md`.

### 3. ImplÃ©menter lâ€™encodeur / dÃ©codeur

Pour USCâ€‘96 (cas le plus simple) :

- **Encodeur** :  
  - entrÃ©e : liste dâ€™IDs USC (0..95) ;  
  - sortie : tableau dâ€™octets ;  
  - chaque symbole : `octet = ID & 0x7F` (MSB = 0).
- **DÃ©codeur** :  
  - entrÃ©e : flux dâ€™octets ;  
  - sortie : liste dâ€™IDs ;  
  - pour chaque octet : `ID = octet & 0x7F`, vÃ©rifier `ID â‰¤ 95` (en USCâ€‘96 strict).

Pour USCâ€‘128 / USCâ€‘256 :

- mÃªme principe, mais :
  - plage dâ€™IDs Ã©tendue (0..127, 0..255) ;
  - gestion des profils en enâ€‘tÃªte de trame (voir ciâ€‘dessous).

RÃ©fÃ©rence :  
â†’ `book/PartVI_AnnexeG_ImplRef.md` (pseudoâ€‘code encodeur/dÃ©codeur, trames, JSON).

### 4. DÃ©finir un format de trame

Un format de trame binaire de rÃ©fÃ©rence est proposÃ© dans lâ€™Annexe G, par exemple :

- enâ€‘tÃªte :
  - MAGIC (`0x55 0x43`),
  - VERSION,
  - PROFILE (USCâ€‘96 / USCâ€‘128 / USCâ€‘256),
  - LENGTH (N symboles) ;
- payload :
  - N octets USC (1 symbole par octet) ;
- suffixe :
  - CHECKSUM (CRCâ€‘16 ou autre).

Vous pouvez :

- rÃ©utiliser ce format tel quel ;
- ou dÃ©finir un format propriÃ©taire, Ã  condition de **documenter clairement** :
  - le profil USC,
  - lâ€™encodage des symboles,
  - les mÃ©canismes de contrÃ´le dâ€™intÃ©gritÃ©.

### 5. Mapper USC â†” structures internes

Selon vos besoins :

- utiliser lâ€™EBNF de lâ€™Annexe B pour :
  - structurer vos messages en expressions (`ent-expr`, `rel-expr`, `op-expr`, `struct-expr`, etc.) ;
  - gÃ©nÃ©rer / parser des arbres ou graphes conceptuels ;
- utiliser MML (Minimal Markup Language, tel que dÃ©crit dans les parties I/III/IV) pour :
  - sÃ©rialiser ces structures dans des formats textuels ou binaires plus riches.

RÃ©fÃ©rence :  
â†’ `book/PartIII_Chapter09_GrammaireInterne.md`  
â†’ `book/PartVI_AnnexeB_EBNF.md`.

### 6. IntÃ©grer USC dans vos protocoles

Quelques exemples dâ€™intÃ©gration :

- **LoRa / HF** :
  - USCâ€‘96 comme payload compact dans vos trames ;
  - profils dÃ©diÃ©s par type dâ€™appareil (tÃ©lÃ©mÃ©trie, commandes, alertes).
- **HTTP / WebSocket** :
  - corps `application/usc+json` (tableaux dâ€™IDs USC + meta) ;
  - endpoints REST spÃ©cialisÃ©s pour messages conceptuels.
- **IA / LLMs** :
  - encodeur/dÃ©codeur USC pour projeter des raisonnements dans lâ€™espace USC ;
  - mode â€œtrace USCâ€ pour lâ€™audit et la comparaison entre modÃ¨les.

RÃ©fÃ©rence :  
â†’ `book/PartIV_Chapter10_CompatReseauxContraints.md` Ã  `PartIV_Chapter14_CompatMaterielle.md`  
â†’ `book/PartVI_AnnexeC_DiagrammesCompat.md` et `PartVI_AnnexeD_ExemplesEncodage.md`.

### 7. SÃ©curitÃ© & audit

Pour des applications critiques :

- utiliser les mÃ©canismes de :
  - **hashing symbolique** (hash des graphes USC) ;
  - **canonisation signÃ©e** (trace USC canonique + signature) ;
  - **mÃ©tadonnÃ©es USC** (`META-*`, `DISC-*`) pour tracer auteur, source, confiance, timestamp.

RÃ©fÃ©rence :  
â†’ `book/PartV_Chapter15_CryptoUSC.md`  
â†’ `book/PartV_Chapter16_Antilogs.md`.

Publication GitHub / contributions
----------------------------------

Pour publier ce dÃ©pÃ´t sur GitHub :

- garder la structure actuelle (`book/`, `usc_*_table.md`, `README.md`) ;
- ajouter Ã©ventuellement :
  - un `LICENSE` (MIT, Apacheâ€‘2.0, ou autre selon ton choix) ;
  - un `CONTRIBUTING.md` expliquant comment proposer :
    - de nouveaux symboles (en vue dâ€™USCâ€‘512),
    - des corrections de gloss / classes,
    - des implÃ©mentations de rÃ©fÃ©rence.

Il est recommandÃ© de :

- lier depuis le `README.md` vers :
  - les chapitres de dÃ©part (prÃ©face + Partie I) ;
  - lâ€™index thÃ©matique ;
  - lâ€™Annexe G pour les dÃ©veloppeurs ;
- taguer les versions (`v0.1`, `v0.2`, etc.) au fur et Ã  mesure des Ã©volutions de la norme.


